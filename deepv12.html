<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Ford‚ÄëJohnson ¬∑ multi‚Äëflowchart ¬∑ stylish ¬∑ keyboard up/down</title>
    <!-- Mermaid for flowchart -->
    <script src="https://cdn.jsdelivr.net/npm/mermaid@11.4.1/dist/mermaid.min.js"></script>
    <style>
        /* === GLOBAL === */
        * {
            box-sizing: border-box;
            font-family: 'Consolas', 'Monaco', monospace;
        }
        body {
            background: #1e1e2f;
            color: #ddd;
            padding: 20px;
            margin: 0;
            display: flex;
            flex-direction: column;
            height: 100vh;
        }
        .input-area {
            background: #2a2a3a;
            padding: 15px;
            border-radius: 10px;
            margin-bottom: 15px;
            display: flex;
            align-items: center;
            gap: 15px;
            flex-wrap: wrap;
        }
        .controls {
            background: #2a2a3a;
            padding: 15px;
            border-radius: 10px;
            margin-bottom: 15px;
            display: flex;
            align-items: center;
            gap: 20px;
            flex-wrap: wrap;
        }
        .btn {
            background: #5f9ea0;
            border: none;
            color: white;
            padding: 8px 18px;
            border-radius: 6px;
            font-weight: bold;
            cursor: pointer;
            transition: 0.2s;
            font-size: 16px;
        }
        .btn:hover {
            background: #7acbcd;
            box-shadow: 0 0 8px #5f9ea0;
        }
        .btn.small {
            padding: 6px 14px;
            font-size: 14px;
        }
        .btn.option {
            background: #3a4a5a;
            margin-right: 8px;
            margin-bottom: 8px;
        }
        .btn.option:hover {
            background: #4f6f8a;
        }
        /* Pulsing glow effect for Jacobsthal button */
        .btn-pulse {
            animation: pulse 1.5s infinite;
            box-shadow: 0 0 0 0 rgba(95, 158, 160, 0.7);
        }
        @keyframes pulse {
            0% { box-shadow: 0 0 0 0 rgba(95, 158, 160, 0.7); }
            70% { box-shadow: 0 0 0 12px rgba(95, 158, 160, 0); }
            100% { box-shadow: 0 0 0 0 rgba(95, 158, 160, 0); }
        }
        .slider-container {
            display: flex;
            align-items: center;
            gap: 15px;
            flex: 1;
        }
        input[type=range] {
            width: 100%;
            cursor: pointer;
            background: #444;
            height: 8px;
            border-radius: 4px;
            accent-color: #5f9ea0;
        }
        .stats {
            background: #3a3a4e;
            padding: 8px 16px;
            border-radius: 20px;
            font-size: 15px;
        }
        .main-panel {
            display: flex;
            gap: 20px;
            flex: 1;
            min-height: 0;
        }
        /* === LEFT PANEL ‚Äì two independent scrollable blocks with size ratio 3:1 === */
        .left-panel {
            flex: 1.2;
            background: #252535;
            border-radius: 12px;
            padding: 15px;
            display: flex;
            flex-direction: column;
            gap: 20px;
            overflow: hidden;
        }
        .stack-section {
            display: flex;
            flex-direction: column;
            flex: 3;
            min-height: 0;
        }
        .stack-section h3 {
            margin: 0 0 8px 0;
            flex-shrink: 0;
        }
        .stack-scroll {
            flex: 1;
            overflow-y: auto;
            padding-right: 5px;
            scrollbar-width: thin;
            scrollbar-color: #5f9ea0 #2a2a3a;
        }
        .stack-scroll::-webkit-scrollbar {
            width: 8px;
        }
        .stack-scroll::-webkit-scrollbar-track {
            background: #2a2a3a;
            border-radius: 10px;
        }
        .stack-scroll::-webkit-scrollbar-thumb {
            background: #5f9ea0;
            border-radius: 10px;
        }
        .stack-scroll::-webkit-scrollbar-thumb:hover {
            background: #7acbcd;
        }
        .memory-section {
            display: flex;
            flex-direction: column;
            flex: 1;
            min-height: 0;
        }
        .memory-section h3 {
            margin: 0 0 8px 0;
            flex-shrink: 0;
        }
        .memory-scroll {
            flex: 1;
            overflow-y: auto;
            padding-right: 5px;
            scrollbar-width: thin;
            scrollbar-color: #5f9ea0 #2a2a3a;
        }
        .memory-scroll::-webkit-scrollbar {
            width: 8px;
        }
        .memory-scroll::-webkit-scrollbar-track {
            background: #2a2a3a;
            border-radius: 10px;
        }
        .memory-scroll::-webkit-scrollbar-thumb {
            background: #5f9ea0;
            border-radius: 10px;
        }
        .memory-scroll::-webkit-scrollbar-thumb:hover {
            background: #7acbcd;
        }
        /* === RIGHT PANEL === */
        .right-panel {
            flex: 1.1;
            background: #252535;
            border-radius: 12px;
            padding: 15px;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }
        .stack-frame {
            background: #2f2f41;
            border-left: 5px solid #7b9eb0;
            margin-bottom: 12px;
            padding: 12px;
            border-radius: 6px;
            box-shadow: 0 2px 6px rgba(0,0,0,0.5);
            cursor: pointer;
            transition: 0.1s;
        }
        .stack-frame.selected {
            border-left-color: #ffb86b;
            background: #3e3e5a;
        }
        .frame-header {
            display: flex;
            justify-content: space-between;
            font-weight: bold;
            color: #ffb86b;
            margin-bottom: 8px;
        }
        .var-list {
            display: grid;
            grid-template-columns: auto 1fr;
            gap: 6px 15px;
            font-size: 13px;
            color: #ccc;
        }
        .var-name {
            color: #9cdcfe;
        }
        .var-value {
            color: #ce9178;
            word-break: break-word;
        }
        .memory-layout {
            background: #0e0e16;
            border-radius: 8px;
            padding: 15px;
            font-size: 13px;
            display: flex;
            gap: 25px;
            flex-wrap: wrap;
        }
        .stack-mem {
            flex: 1;
        }
        .heap-mem {
            flex: 1;
        }
        .mem-box {
            background: #1a1a26;
            padding: 8px;
            border-radius: 5px;
            margin-top: 6px;
            border: 1px solid #444;
        }
        .array-viz {
            display: flex;
            gap: 6px;
            flex-wrap: wrap;
            margin-top: 8px;
            align-items: center;
        }
        .array-cell {
            background: #2d2d3a;
            padding: 8px 12px;
            border-radius: 5px;
            font-weight: 600;
            color: #f1fa8c;
            border: 1px solid #6272a4;
            min-width: 45px;
            text-align: center;
        }
        .array-index {
            font-size: 11px;
            color: #888;
            margin-top: 2px;
        }
        h3 {
            color: #dfeaff;
            margin-top: 0;
            margin-bottom: 12px;
            border-bottom: 1px solid #4a4a66;
            padding-bottom: 5px;
        }
        #numberInput {
            background: #1e1e2a;
            border: 1px solid #5f9ea0;
            color: #ddd;
            padding: 8px 15px;
            border-radius: 20px;
            width: 300px;
            font-size: 15px;
        }
        #randomCount {
            background: #1e1e2a;
            border: 1px solid #5f9ea0;
            color: #ddd;
            padding: 8px 12px;
            border-radius: 20px;
            width: 80px;
            font-size: 15px;
            text-align: center;
        }
        footer {
            margin-top: 10px;
            text-align: right;
            color: #7f8c8d;
            font-size: 12px;
        }
        .key-hint {
            color: #aaa;
            font-size: 13px;
            margin-left: 10px;
        }
        /* === COMMENT BOX with custom scrollbar === */
        .comment-box {
            background: #1e1e2a;
            border-left: 6px solid #5f9ea0;
            border-radius: 8px;
            padding: 16px;
            margin-bottom: 15px;
            color: #f0f0f0;
            font-size: 14px;
            line-height: 1.5;
            box-shadow: 0 2px 6px rgba(0,0,0,0.6);
            overflow-y: auto;
            max-height: 220px;
            scrollbar-width: thin;
            scrollbar-color: #5f9ea0 #2a2a3a;
        }
        .comment-box::-webkit-scrollbar {
            width: 8px;
        }
        .comment-box::-webkit-scrollbar-track {
            background: #2a2a3a;
            border-radius: 10px;
        }
        .comment-box::-webkit-scrollbar-thumb {
            background: #5f9ea0;
            border-radius: 10px;
        }
        .comment-box::-webkit-scrollbar-thumb:hover {
            background: #7acbcd;
        }
        .comment-icon {
            color: #ffb86b;
            font-weight: bold;
            margin-right: 8px;
        }
        .jacobsthal-detail {
            margin-top: 12px;
            padding-top: 12px;
            border-top: 1px dashed #5f9ea0;
            color: #b0e0e6;
            font-size: 13px;
        }
        /* === MODAL OVERLAY (common) === */
        .modal-overlay {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.7);
            align-items: center;
            justify-content: center;
            z-index: 1000;
        }
        .modal-content {
            background: #252535;
            border-left: 8px solid #5f9ea0;
            border-radius: 12px;
            padding: 25px;
            width: 800px;
            max-width: 95%;
            max-height: 85vh;
            overflow-y: auto;
            color: #ddd;
            box-shadow: 0 10px 30px rgba(0,0,0,0.8);
            position: relative;
            scrollbar-width: thin;
            scrollbar-color: #5f9ea0 #2a2a3a;
        }
        .modal-content::-webkit-scrollbar {
            width: 8px;
        }
        .modal-content::-webkit-scrollbar-track {
            background: #2a2a3a;
            border-radius: 10px;
        }
        .modal-content::-webkit-scrollbar-thumb {
            background: #5f9ea0;
            border-radius: 10px;
        }
        .modal-content::-webkit-scrollbar-thumb:hover {
            background: #7acbcd;
        }
        .modal-close {
            position: absolute;
            top: 15px;
            right: 20px;
            font-size: 24px;
            cursor: pointer;
            color: #aaa;
            transition: 0.2s;
        }
        .modal-close:hover {
            color: #ffb86b;
        }
        .modal-title {
            color: #ffb86b;
            font-size: 20px;
            margin-bottom: 20px;
            border-bottom: 1px solid #5f9ea0;
            padding-bottom: 10px;
        }
        .modal-step {
            background: #1e1e2a;
            padding: 12px;
            border-radius: 6px;
            margin-bottom: 15px;
            border-left: 4px solid #5f9ea0;
        }
        .modal-highlight {
            color: #f1fa8c;
            font-weight: bold;
        }
        /* Mermaid diagram styling */
        .mermaid-wrapper {
            background: #1e1e2a;
            padding: 20px;
            border-radius: 12px;
            margin-top: 15px;
            border: 1px solid #5f9ea0;
            overflow-x: auto;
        }
        .mermaid {
            background: transparent;
        }
        .flowchart-desc {
            margin-top: 12px;
            color: #b0e0e6;
            font-style: italic;
            border-top: 1px dashed #5f9ea0;
            padding-top: 10px;
        }
        .option-bar {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            margin-bottom: 15px;
        }
    </style>
</head>
<body>
    <!-- Input area: live update + random generator -->
    <div class="input-area">
        <label for="numberInput" style="color:#dfeaff;">üî¢ Numbers (comma/space separated):</label>
        <input type="text" id="numberInput" value="5 2 8 3 1 7 4 6" placeholder="e.g. 5 2 8 3 1 7 4 6">
        <button class="btn" id="resetBtn">‚ü≤ Reset</button>
        <div style="display: flex; align-items: center; gap: 8px; margin-left: 10px;">
            <span style="color:#dfeaff;">üé≤ Random (1‚Äë100)</span>
            <input type="number" id="randomCount" min="1" max="30" value="8" step="1">
            <button class="btn small" id="randomBtn">Generate</button>
        </div>
        <span style="color:#aaa; margin-left:5px;">(updates as you type)</span>
    </div>

    <div class="controls">
        <button class="btn" id="firstBtn">‚èÆ First</button>
        <button class="btn" id="prevBtn">‚óÄ Prev</button>
        <button class="btn" id="nextBtn">Next ‚ñ∂</button>
        <button class="btn" id="lastBtn">‚è≠ Last</button>
        <div class="slider-container">
            <span>Step</span>
            <input type="range" id="stepSlider" min="0" max="0" value="0" step="1">
            <span id="stepLabel">0 / 0</span>
        </div>
        <div class="stats">
            ‚öñÔ∏è Comparisons: <span id="cmpCount">0</span>
        </div>
        <!-- Flowchart button -->
        <button class="btn" id="flowchartBtn">üìä Flowcharts</button>
        <!-- Jacobsthal button with pulsing effect -->
        <button class="btn" id="jacobsthalModalBtn">üìò Jacobsthal steps</button>
        <span class="key-hint">‚Üê ‚Üí prev/next, ‚Üë last, ‚Üì first</span>
    </div>

    <div class="main-panel">
        <!-- LEFT PANEL: two independent scrollable sections with 3:1 ratio -->
        <div class="left-panel">
            <div class="stack-section">
                <h3>üìö Call stack</h3>
                <div class="stack-scroll" id="callStackScroll">
                    <div id="callStackContainer"></div>
                </div>
            </div>
            <div class="memory-section">
                <h3>üß† Memory layout</h3>
                <div class="memory-scroll" id="memoryScroll">
                    <div id="memoryLayout"></div>
                </div>
            </div>
        </div>

        <!-- RIGHT PANEL: comments, locals, vector visual -->
        <div class="right-panel">
            <h3>üìù Step comment</h3>
            <div id="stepComment" class="comment-box"></div>
            <h3>üî¨ Current frame variables</h3>
            <div id="localVarsPanel" style="background: #1e1e2a; border-radius: 8px; padding: 15px; overflow-y: auto; flex: 1;"></div>
            <div style="margin-top: 20px;">
                <h3>üìä vector content</h3>
                <div id="vectorVisual" style="background: #1e1e2a; border-radius: 8px; padding: 15px;"></div>
            </div>
        </div>
    </div>

    <!-- MODAL: Jacobsthal steps -->
    <div id="jacobsthalModal" class="modal-overlay">
        <div class="modal-content">
            <span id="modalCloseBtn" class="modal-close">&times;</span>
            <div class="modal-title">üîç Jacobsthal insertion order ‚Äì new algorithm (1,3 start)</div>
            <div id="modalBody" style="font-size: 14px; line-height: 1.6;">
                <!-- dynamic content -->
            </div>
        </div>
    </div>

    <!-- MODAL: Multi-flowchart selector -->
    <div id="flowchartModal" class="modal-overlay">
        <div class="modal-content" style="width: 900px;">
            <span id="flowchartCloseBtn" class="modal-close">&times;</span>
            <div class="modal-title">üìä Ford‚ÄëJohnson ‚Äì select a flowchart</div>
            <div class="option-bar">
                <button class="btn option" data-flowchart="overall">üìå Overall algorithm</button>
                <button class="btn option" data-flowchart="pairs">üîπ Pair creation</button>
                <button class="btn option" data-flowchart="winners">üèÜ Winner extraction & reorder</button>
                <button class="btn option" data-flowchart="jacobsthal">üî¢ Jacobsthal order</button>
                <button class="btn option" data-flowchart="insert">üì• Pending insertion</button>
            </div>
            <div id="flowchartDisplay" class="mermaid-wrapper">
                <div class="mermaid" id="mermaidDiagram">
                    <!-- Dynamic diagram will be inserted here -->
                </div>
                <div id="flowchartDesc" class="flowchart-desc">
                    <!-- Description will appear here -->
                </div>
            </div>
        </div>
    </div>

    <footer>‚ö° Ford‚ÄëJohnson ¬∑ multi‚Äëflowchart ¬∑ stylish ¬∑ keyboard up/down</footer>

    <script>
        // Initialize Mermaid with safer settings
        mermaid.initialize({
            startOnLoad: false,
            securityLevel: 'loose',
            theme: 'dark'
        });

        // ------------------------------------------------------------
        //  GLOBAL STATE & ALGORITHM (UPDATED Jacobsthal)
        // ------------------------------------------------------------
        let comparisonCount = 0;

        function lessThanWithCount(a, b) {
            comparisonCount++;
            return a < b;
        }

        // 1) createWinnerLoserPairs
        function createWinnerLoserPairs(vec) {
            let pairs = [];
            for (let i = 0; i + 1 < vec.length; i += 2) {
                let p = {};
                if (lessThanWithCount(vec[i], vec[i + 1])) {
                    p.winner = vec[i + 1];
                    p.loser = vec[i];
                } else {
                    p.winner = vec[i];
                    p.loser = vec[i + 1];
                }
                pairs.push({ winner: p.winner, loser: p.loser });
            }
            return pairs;
        }

        // 2) extractStraggler
        function extractStraggler(vec) {
            return vec.length % 2 ? vec[vec.length - 1] : -1;
        }

        // 3) extractWinners
        function extractWinners(pairs) {
            let winners = [];
            for (let i = 0; i < pairs.length; i++) winners.push(pairs[i].winner);
            return winners;
        }

        // 4) orderPairsByWinners
        function orderPairsByWinners(pairs, sortedWinners) {
            let orderedPairs = [];
            for (let i = 0; i < sortedWinners.length; i++) {
                for (let j = 0; j < pairs.length; j++) {
                    if (pairs[j].winner === sortedWinners[i]) {
                        orderedPairs.push({ winner: pairs[j].winner, loser: pairs[j].loser });
                        pairs[j].winner = -1;
                        break;
                    }
                }
            }
            return orderedPairs;
        }

        // 5) buildInitialChain
        function buildInitialChain(orderedPairs, totalSize) {
            let chain = [];
            chain.push(orderedPairs[0].loser);
            for (let i = 0; i < orderedPairs.length; i++) chain.push(orderedPairs[i].winner);
            return chain;
        }

        // 6) initializeInsertionBounds
        function initializeInsertionBounds(numberOfPairs) {
            let bounds = [];
            for (let i = 0; i < numberOfPairs; i++) bounds.push(i + 1);
            return bounds;
        }

        // 7) generateJacobsthalNumbersUpTo (UPDATED: starts with [1,3])
        function generateJacobsthalNumbersUpTo(jacobsthalArray, limit) {
            while (jacobsthalArray[jacobsthalArray.length - 1] < limit) {
                let next = jacobsthalArray[jacobsthalArray.length - 1] + 2 * jacobsthalArray[jacobsthalArray.length - 2];
                jacobsthalArray.push(next);
            }
        }

        // 8) generateInsertionOrder (UPDATED ‚Äì matches new C++ version)
        function generateInsertionOrder(pendingCount) {
            let insertionOrder = [];
            if (pendingCount === 0) return insertionOrder;
            
            let jacobsthal = [1, 3];  // start with 1,3 (index 0 and 1)
            generateJacobsthalNumbersUpTo(jacobsthal, pendingCount);
            
            let used = new Array(pendingCount).fill(false);
            
            for (let k = 1; k < jacobsthal.length; k++) {
                let start = jacobsthal[k];
                let end = jacobsthal[k - 1];
                for (let i = start; i > end; i--) {
                    let idx = i - 2;
                    if (idx >= 0 && idx < pendingCount && !used[idx]) {
                        insertionOrder.push(idx);
                        used[idx] = true;
                    }
                }
            }
            
            for (let i = 0; i < pendingCount; i++) {
                if (!used[i]) insertionOrder.push(i);
            }
            return insertionOrder;
        }

        // 9) lowerBound
        function lowerBound(arr, val, left, right, comp) {
            let lo = left, hi = right;
            while (lo < hi) {
                let mid = Math.floor((lo + hi) / 2);
                if (comp(arr[mid], val)) lo = mid + 1;
                else hi = mid;
            }
            return lo;
        }

        // 10) insertPendingElements
        function insertPendingElements(insertionOrder, orderedPairs, chain, insertionBounds, straggler) {
            for (let step = 0; step < insertionOrder.length; step++) {
                let value, searchLimit;
                if (insertionOrder[step] === orderedPairs.length - 1 && straggler !== -1) {
                    value = straggler;
                    searchLimit = chain.length;
                } else {
                    let idx = insertionOrder[step] + 1;
                    value = orderedPairs[idx].loser;
                    searchLimit = insertionBounds[idx];
                }
                let insertIndex = lowerBound(chain, value, 0, searchLimit, lessThanWithCount);
                chain.splice(insertIndex, 0, value);
                for (let i = 0; i < insertionBounds.length; i++) {
                    if (insertionBounds[i] >= insertIndex) insertionBounds[i]++;
                }
            }
        }

        // ------------------------------------------------------------
        //  RECURSIVE SORT ‚Äì fordJohnsonSort
        // ------------------------------------------------------------
        function fordJohnsonSort(vec, depth = 0, stepRecorder = null, frameIdCounter = { id: 0 }) {
            let frameId = ++frameIdCounter.id;
            let frame = {
                id: frameId,
                depth: depth,
                name: 'fordJohnsonSort',
                params: { v: deepCopy(vec) },
                locals: {}
            };
            if (stepRecorder) stepRecorder.callStack.push(frame);
            if (stepRecorder) stepRecorder.record('enter', frame, vec, null, null, depth);

            if (vec.length === 1) {
                if (stepRecorder) stepRecorder.record('base case (size=1)', frame, vec, null, null, depth);
                if (stepRecorder) stepRecorder.callStack.pop();
                return;
            }
            if (vec.length === 2) {
                if (!lessThanWithCount(vec[0], vec[1])) [vec[0], vec[1]] = [vec[1], vec[0]];
                if (stepRecorder) stepRecorder.record('base case (size=2, swap if needed)', frame, vec, null, null, depth);
                if (stepRecorder) stepRecorder.callStack.pop();
                return;
            }

            let pairs = createWinnerLoserPairs(vec);
            frame.locals.pairs = deepCopy(pairs);
            if (stepRecorder) stepRecorder.record('after createWinnerLoserPairs', frame, vec, pairs, null, depth);

            let straggler = extractStraggler(vec);
            frame.locals.straggler = straggler;
            if (stepRecorder) stepRecorder.record('after extractStraggler', frame, vec, pairs, straggler, depth);

            let winners = extractWinners(pairs);
            frame.locals.winners = deepCopy(winners);
            if (stepRecorder) stepRecorder.record('after extractWinners', frame, vec, winners, straggler, depth);

            if (stepRecorder) stepRecorder.record('before recursive fordJohnsonSort(winners)', frame, vec, winners, straggler, depth);
            fordJohnsonSort(winners, depth + 1, stepRecorder, frameIdCounter);
            frame.locals.winners = deepCopy(winners);
            if (stepRecorder) stepRecorder.record('after recursive fordJohnsonSort(winners)', frame, vec, winners, straggler, depth);

            let orderedPairs = orderPairsByWinners(pairs, winners);
            frame.locals.orderedPairs = deepCopy(orderedPairs);
            if (stepRecorder) stepRecorder.record('after orderPairsByWinners', frame, vec, orderedPairs, straggler, depth);

            let chain = buildInitialChain(orderedPairs, vec.length);
            frame.locals.chain = deepCopy(chain);
            if (stepRecorder) stepRecorder.record('after buildInitialChain', frame, vec, chain, straggler, depth);

            let insertionBounds = initializeInsertionBounds(orderedPairs.length);
            frame.locals.insertionBounds = deepCopy(insertionBounds);
            if (stepRecorder) stepRecorder.record('after initializeInsertionBounds', frame, vec, insertionBounds, straggler, depth);

            let pendingCount = (orderedPairs.length - 1) + (straggler === -1 ? 0 : 1);
            let insertionOrder = generateInsertionOrder(pendingCount);
            frame.locals.pendingCount = pendingCount;
            frame.locals.insertionOrder = deepCopy(insertionOrder);
            if (stepRecorder) stepRecorder.record('after generateInsertionOrder', frame, vec, insertionOrder, straggler, depth);

            insertPendingElements(insertionOrder, orderedPairs, chain, insertionBounds, straggler);
            frame.locals.chain = deepCopy(chain);
            frame.locals.insertionBounds = deepCopy(insertionBounds);
            if (stepRecorder) stepRecorder.record('after insertPendingElements', frame, vec, chain, straggler, depth);

            vec.length = 0;
            chain.forEach(x => vec.push(x));
            frame.locals.v = deepCopy(vec);
            if (stepRecorder) stepRecorder.record('exit (vec = chain)', frame, vec, chain, straggler, depth);

            if (stepRecorder) stepRecorder.callStack.pop();
        }

        // ------------------------------------------------------------
        //  STEP RECORDER ‚Äì updated comment for new Jacobsthal
        // ------------------------------------------------------------
        class StepRecorder {
            constructor() {
                this.steps = [];
                this.callStack = [];
            }

            record(phase, currentFrame, currentVec, extra, straggler, depth) {
                let comment = this.generateComment(phase, currentVec, extra, straggler, depth, comparisonCount);
                let snapshot = {
                    step: this.steps.length,
                    phase: phase,
                    comment: comment,
                    g_comp: comparisonCount,
                    callStack: deepCopy(this.callStack.map(f => ({
                        id: f.id,
                        depth: f.depth,
                        name: f.name,
                        params: f.params,
                        locals: f.locals
                    }))),
                    heapMap: this.generateHeapLayout()
                };
                if (this.callStack.length > 0) {
                    let top = this.callStack[this.callStack.length - 1];
                    snapshot.callStack[snapshot.callStack.length - 1].locals = deepCopy(top.locals);
                }
                this.steps.push(snapshot);
            }

            generateComment(phase, vec, extra, straggler, depth, cmpCount) {
                const prefix = `üîπ Depth ${depth} ¬∑ Comparisons: ${cmpCount}\n`;
                let mainComment = '';
                
                if (phase.includes('enter')) mainComment = `üü¢ Entered fordJohnsonSort() with vector [${vec.join(', ')}].`;
                else if (phase.includes('base case')) {
                    if (vec.length === 1) mainComment = `‚ö™ Base case: vector size 1 ‚Üí already sorted. Returning.`;
                    else mainComment = `‚ö™ Base case: vector size 2 ‚Üí swapped if needed. Now [${vec.join(', ')}].`;
                }
                else if (phase.includes('createWinnerLoserPairs')) mainComment = `‚û°Ô∏è Created winner/loser pairs: ${formatPairArray(extra)}.`;
                else if (phase.includes('extractStraggler')) mainComment = `‚û°Ô∏è Straggler (unpaired element): ${straggler === -1 ? 'none' : straggler}.`;
                else if (phase.includes('extractWinners')) mainComment = `‚û°Ô∏è Extracted winners: [${extra.join(', ')}]. These will be sorted recursively.`;
                else if (phase.includes('before recursive')) mainComment = `‚¨áÔ∏è Recursively sorting winners: [${extra.join(', ')}].`;
                else if (phase.includes('after recursive')) mainComment = `‚¨ÜÔ∏è Recursion finished. Winners are now sorted: [${extra.join(', ')}].`;
                else if (phase.includes('orderPairsByWinners')) mainComment = `‚û°Ô∏è Reordered pairs according to sorted winners: ${formatPairArray(extra)}.`;
                else if (phase.includes('buildInitialChain')) mainComment = `‚û°Ô∏è Built initial main chain: [${extra.join(', ')}] (first loser + all winners).`;
                else if (phase.includes('initializeInsertionBounds')) mainComment = `‚û°Ô∏è Insertion bounds initialized: [${extra.join(', ')}].`;
                else if (phase.includes('generateInsertionOrder')) {
                    mainComment = `‚û°Ô∏è Generated Jacobsthal insertion order (new algorithm) for ${extra.length} pending elements: [${extra.join(', ')}].`;
                    mainComment += `<div class="jacobsthal-detail">`;
                    mainComment += `<span style="color:#ffb86b;">üîç New Jacobsthal method (starts with 1,3):</span><br>`;
                    mainComment += `‚Ä¢ J(0)=1, J(1)=3, J(n)=J(n-1)+2¬∑J(n-2)<br>`;
                    mainComment += `‚Ä¢ For each batch from J(k) down to J(k-1)+1, push index = i-2.<br>`;
                    mainComment += `‚Ä¢ This produces the optimal insertion order. Click "üìò Jacobsthal steps" for a full walkthrough with your current numbers.`;
                    mainComment += `</div>`;
                }
                else if (phase.includes('insertPendingElements')) mainComment = `‚û°Ô∏è Inserted all pending elements. Main chain is now: [${extra.join(', ')}].`;
                else if (phase.includes('exit')) mainComment = `‚úÖ Function finished. Vector replaced with sorted chain: [${extra.join(', ')}]. Returning.`;
                else mainComment = `üìç ${phase}.`;

                return prefix + mainComment;
            }

            generateHeapLayout() {
                let heap = {};
                let addr = 0x1000;
                this.callStack.forEach(frame => {
                    Object.keys(frame.locals).forEach(key => {
                        let val = frame.locals[key];
                        if (Array.isArray(val) && key !== 'insertionBounds') {
                            let id = `frame_${frame.id}_${key}`;
                            heap[id] = { 
                                address: addr, 
                                content: deepCopy(val), 
                                size: val.length, 
                                capacity: val.length 
                            };
                            addr += 0x40;
                        }
                    });
                    if (frame.params?.v) {
                        let id = `frame_${frame.id}_param_v`;
                        heap[id] = { 
                            address: addr, 
                            content: deepCopy(frame.params.v), 
                            size: frame.params.v.length, 
                            capacity: frame.params.v.length 
                        };
                        addr += 0x40;
                    }
                });
                return heap;
            }
        }

        // ------------------------------------------------------------
        //  UTILITIES
        // ------------------------------------------------------------
        function deepCopy(obj) { return JSON.parse(JSON.stringify(obj)); }
        
        function formatPairArray(arr) {
            if (!Array.isArray(arr)) return JSON.stringify(arr);
            if (arr.length === 0) return '[]';
            if (typeof arr[0] === 'object' && arr[0] !== null && 'winner' in arr[0] && 'loser' in arr[0]) {
                return '[' + arr.map(p => `{W:${p.winner}, L:${p.loser}}`).join(', ') + ']';
            }
            return '[' + arr.join(', ') + ']';
        }

        function formatHeapContent(content) {
            if (!Array.isArray(content)) return JSON.stringify(content);
            if (content.length === 0) return '[]';
            if (typeof content[0] === 'object' && content[0] !== null) {
                return '[' + content.map(p => `{W:${p.winner}, L:${p.loser}}`).join(', ') + ']';
            }
            return '[' + content.join(', ') + ']';
        }

        function parseInput(str) {
            let normalized = str.replace(/,/g, ' ');
            let tokens = normalized.split(/\s+/).filter(s => s !== '');
            return tokens.map(Number).filter(n => !isNaN(n));
        }

        // ------------------------------------------------------------
        //  UI RENDERING
        // ------------------------------------------------------------
        let steps = [];
        let currentStep = 0;

        function renderStep(index) {
            if (steps.length === 0) return;
            let step = steps[index];
            document.getElementById('cmpCount').innerText = step.g_comp;
            document.getElementById('stepLabel').innerText = `${index} / ${steps.length-1}`;
            document.getElementById('stepSlider').max = steps.length-1;
            document.getElementById('stepSlider').value = index;
            document.getElementById('stepComment').innerHTML = `<span class="comment-icon">üí¨</span> ${step.comment.replace(/\n/g, '<br>')}`;

            // Add pulsing effect to Jacobsthal button if current phase is Jacobsthal generation
            const jacobsthalBtn = document.getElementById('jacobsthalModalBtn');
            if (step.phase.includes('generateInsertionOrder')) {
                jacobsthalBtn.classList.add('btn-pulse');
            } else {
                jacobsthalBtn.classList.remove('btn-pulse');
            }

            renderCallStack(step.callStack);
            renderMemoryLayout(step.callStack, step.heapMap);
            if (step.callStack.length > 0) {
                renderLocalVars(step.callStack[step.callStack.length-1]);
                renderVectorVisual(step.callStack[step.callStack.length-1]);
            } else {
                document.getElementById('localVarsPanel').innerHTML = '<i>no active frame</i>';
                document.getElementById('vectorVisual').innerHTML = '<i>no vector</i>';
            }
        }

        function renderCallStack(stackFrames) {
            let container = document.getElementById('callStackContainer');
            container.innerHTML = '';
            stackFrames.forEach((frame, idx) => {
                let frameDiv = document.createElement('div');
                frameDiv.className = 'stack-frame';
                frameDiv.setAttribute('data-frame-id', frame.id);
                let header = `<div class="frame-header"><span>üìå fordJohnsonSort() [depth ${frame.depth}]</span><span style="color:#9cdcfe">frame #${frame.id}</span></div>`;
                let paramsHtml = `<div class="var-list"><span class="var-name">v (param):</span><span class="var-value">[${frame.params.v.join(', ')}]</span></div>`;
                let localsDiv = document.createElement('div');
                localsDiv.className = 'var-list';
                localsDiv.style.marginTop = '8px';
                let localsHtml = '';
                if (Object.keys(frame.locals).length > 0) {
                    localsHtml += '<span style="color:#ffb86b; grid-column: span 2;">locals:</span>';
                    for (let [k, val] of Object.entries(frame.locals)) {
                        let display = formatPairArray(val);
                        localsHtml += `<span class="var-name">${k}:</span><span class="var-value">${display}</span>`;
                    }
                } else localsHtml = '<i style="grid-column: span 2;">no locals yet</i>';
                localsDiv.innerHTML = localsHtml;
                frameDiv.innerHTML = header + paramsHtml;
                frameDiv.appendChild(localsDiv);
                frameDiv.addEventListener('click', (e) => {
                    e.stopPropagation();
                    document.querySelectorAll('.stack-frame').forEach(f => f.classList.remove('selected'));
                    frameDiv.classList.add('selected');
                    renderLocalVars(frame);
                    renderVectorVisual(frame);
                });
                container.appendChild(frameDiv);
            });
            if (stackFrames.length) {
                let topId = stackFrames[stackFrames.length-1].id;
                let topElem = container.querySelector(`[data-frame-id="${topId}"]`);
                if (topElem) topElem.classList.add('selected');
            }
        }

        function renderMemoryLayout(stackFrames, heapMap) {
            let memDiv = document.getElementById('memoryLayout');
            memDiv.innerHTML = '<h4 style="margin:0 0 10px 0; width:100%;">üß† stack & heap simulation</h4>';
            let stackHtml = '<div class="stack-mem"><span style="color:#9cdcfe;">‚ñº STACK (grows down)</span><div class="mem-box">';
            stackFrames.forEach((frame, i) => {
                stackHtml += `<div style="border-left: 3px solid #5f9ea0; padding-left: 8px; margin-bottom: 10px;">`;
                stackHtml += `<span style="color:#ffb86b;">frame #${frame.id} (depth ${frame.depth})</span><br>`;
                stackHtml += `<span>EBP+0x${(i*0x80).toString(16)}: v ‚Üí [${frame.params.v.join(', ')}] (heap@${heapMap[`frame_${frame.id}_param_v`]?.address.toString(16) || '??'})</span><br>`;
                if (frame.locals.pairs) stackHtml += `<span>EBP+0x${(i*0x80+0x20).toString(16)}: pairs (array)</span><br>`;
                if (frame.locals.winners) stackHtml += `<span>EBP+0x${(i*0x80+0x30).toString(16)}: winners ‚Üí heap@${heapMap[`frame_${frame.id}_winners`]?.address.toString(16) || '??'}</span><br>`;
                if (frame.locals.chain) stackHtml += `<span>EBP+0x${(i*0x80+0x40).toString(16)}: chain ‚Üí heap@${heapMap[`frame_${frame.id}_chain`]?.address.toString(16) || '??'}</span><br>`;
                stackHtml += `</div>`;
            });
            stackHtml += '</div></div>';
            
            let heapHtml = '<div class="heap-mem"><span style="color:#9cdcfe;">‚ñ≤ HEAP (dynamic)</span><div class="mem-box">';
            Object.entries(heapMap).forEach(([id, block]) => {
                let contentDisplay = formatHeapContent(block.content);
                heapHtml += `<div style="margin-bottom: 10px; border-bottom: 1px solid #444; padding-bottom: 5px;">`;
                heapHtml += `<span style="color:#c792ea;">0x${block.address.toString(16)}</span>  <span style="color:#7b9eb0;">${id}</span><br>`;
                heapHtml += `<span>content: ${contentDisplay}  (size=${block.size})</span>`;
                heapHtml += `</div>`;
            });
            heapHtml += '</div></div>';
            memDiv.innerHTML += stackHtml + heapHtml;
        }

        function renderLocalVars(frame) {
            let panel = document.getElementById('localVarsPanel');
            if (!frame) return;
            let html = `<div style="display: grid; grid-template-columns: auto 1fr; gap: 12px 20px;">`;
            html += `<span style="color:#ffb86b;">variable</span><span style="color:#ffb86b;">value</span>`;
            html += `<span class="var-name">v (param)</span><span class="var-value">[${frame.params.v.join(', ')}]</span>`;
            for (let [k, v] of Object.entries(frame.locals)) {
                let display = formatPairArray(v);
                html += `<span class="var-name">${k}</span><span class="var-value">${display}</span>`;
            }
            html += '</div>';
            panel.innerHTML = html;
        }

        function renderVectorVisual(frame) {
            let visDiv = document.getElementById('vectorVisual');
            if (!frame) return;
            let vec = frame.params.v || [];
            let html = '<div style="display:flex; flex-direction:column; gap:10px;">';
            html += '<div style="display:flex; align-items:center; gap:6px; flex-wrap:wrap;">';
            vec.forEach((val, idx) => {
                html += `<div style="display:flex; flex-direction:column; align-items:center;">
                            <div class="array-cell">${val}</div>
                            <span class="array-index">[${idx}]</span>
                          </div>`;
            });
            html += '</div>';
            if (frame.locals.winners) {
                html += `<div style="margin-top:12px;"><span style="color:#9cdcfe;">winners:</span> `;
                frame.locals.winners.forEach(v => html += `<span class="array-cell" style="background:#3e4a5a;">${v}</span> `);
                html += '</div>';
            }
            if (frame.locals.chain) {
                html += `<div style="margin-top:8px;"><span style="color:#9cdcfe;">chain:</span> `;
                frame.locals.chain.forEach(v => html += `<span class="array-cell" style="background:#4a5a6a;">${v}</span> `);
                html += '</div>';
            }
            visDiv.innerHTML = html;
        }

        // ------------------------------------------------------------
        //  JACOBSTHAL MODAL ‚Äì UPDATED for new algorithm
        // ------------------------------------------------------------
        function generateJacobsthalExplanation(pendingCount, insertionOrder) {
            if (pendingCount === undefined || pendingCount === null) {
                return "<p>No active frame with pendingCount. Please select a stack frame that has executed Jacobsthal generation.</p>";
            }
            // Recompute Jacobsthal numbers starting with [1,3]
            let jacobsthal = [1, 3];
            generateJacobsthalNumbersUpTo(jacobsthal, pendingCount);
            
            let html = `<div class="modal-step">`;
            html += `<span style="color:#ffb86b;">üìå Input:</span> pendingCount = <span class="modal-highlight">${pendingCount}</span><br><br>`;

            // Step 1: Jacobsthal generation
            html += `<span style="color:#ffb86b;">1. Generate Jacobsthal numbers (starting 1,3) until ‚â• ${pendingCount}:</span><br>`;
            html += `Start: J0 = 1, J1 = 3<br>`;
            for (let i = 2; i < jacobsthal.length; i++) {
                html += `J${i} = J${i-1} + 2¬∑J${i-2} = ${jacobsthal[i-1]} + 2¬∑${jacobsthal[i-2]} = <span class="modal-highlight">${jacobsthal[i]}</span><br>`;
            }
            html += `‚Üí Jacobsthal numbers up to limit: [${jacobsthal.join(', ')}]<br><br>`;

            // Step 2: Process each batch using new indexing
            html += `<span style="color:#ffb86b;">2. Generate insertion order using batches (k = 1..):</span><br>`;
            let used = new Array(pendingCount).fill(false);
            html += `<table style="border-collapse: collapse; width: 100%; margin-top: 8px;">`;
            html += `<tr><th style="text-align: left; color: #9cdcfe;">k</th><th style="text-align: left; color: #9cdcfe;">J[k]</th><th style="text-align: left; color: #9cdcfe;">J[k-1]</th><th style="text-align: left; color: #9cdcfe;">i range</th><th style="text-align: left; color: #9cdcfe;">idx = i-2</th><th style="text-align: left; color: #9cdcfe;">pushed?</th></tr>`;
            for (let k = 1; k < jacobsthal.length; k++) {
                let start = jacobsthal[k];
                let end = jacobsthal[k - 1];
                let indices = [];
                for (let i = start; i > end; i--) {
                    let idx = i - 2;
                    if (idx >= 0 && idx < pendingCount && !used[idx]) {
                        indices.push(idx);
                        used[idx] = true;
                    }
                }
                if (indices.length > 0) {
                    html += `<tr><td>${k}</td><td>${start}</td><td>${end}</td><td>${start} ‚Üí ${end+1}</td><td>[${indices.map(x => x).join(', ')}]</td><td>‚úÖ</td></tr>`;
                } else {
                    html += `<tr><td>${k}</td><td>${start}</td><td>${end}</td><td>${start} ‚Üí ${end+1}</td><td>‚Äî</td><td>‚ùå (none or already used)</td></tr>`;
                }
            }
            html += `</table><br>`;

            // Remaining numbers (stragglers in insertion order)
            html += `<span style="color:#ffb86b;">3. Append unused indices in ascending order:</span><br>`;
            let remaining = [];
            for (let i = 0; i < pendingCount; i++) if (!used[i]) remaining.push(i);
            html += `Unused: [${remaining.join(', ')}] ‚Üí appended.<br><br>`;

            // Step 3: Final insertion order
            html += `<span style="color:#ffb86b;">4. Final insertion order (0‚Äëbased indices):</span><br>`;
            html += `<span class="modal-highlight" style="font-size: 16px;">[${insertionOrder.join(', ')}]</span><br>`;
            html += `This means: insert pending elements in the order of these indices.<br>`;
            html += `The sequence is optimal because the batch sizes (differences of Jacobsthal numbers) minimise the upper bound for binary search.`;
            html += `</div>`;

            return html;
        }

        // ------------------------------------------------------------
        //  FLOWCHART DEFINITIONS (stylish, with comments)
        // ------------------------------------------------------------
        const flowcharts = {
            overall: {
                title: "Overall Ford‚ÄëJohnson Algorithm",
                diagram: `flowchart TD
    A["Start: fordJohnsonSort(vec)"] --> B{"vec.size() == 1?"}
    B -->|Yes| C["Return"]
    B -->|No| D{"vec.size() == 2?"}
    D -->|Yes| E["Compare and swap if needed, return"]
    D -->|No| F["createWinnerLoserPairs"]
    F --> G["extractStraggler"]
    G --> H["extractWinners"]
    H --> I["Recursive fordJohnsonSort(winners)"]
    I --> J["orderPairsByWinners"]
    J --> K["buildInitialChain"]
    K --> L["initializeInsertionBounds"]
    L --> M["generateInsertionOrder (Jacobsthal)"]
    M --> N["insertPendingElements"]
    N --> O["vec = chain"]
    O --> P["Return"]`,
                desc: "The complete recursive merge‚Äëinsertion sort. Divides into pairs, sorts winners recursively, then inserts pend elements in optimal Jacobsthal order."
            },
            pairs: {
                title: "Pair Creation (createWinnerLoserPairs)",
                diagram: `flowchart TD
    A["Input: vector vec"] --> B["i = 0"]
    B --> C{"i+1 < vec.size?"}
    C -->|No| D["Return pairs"]
    C -->|Yes| E["Compare vec[i] and vec[i+1] with cmp()"]
    E --> F{"vec[i] < vec[i+1]?"}
    F -->|Yes| G["winner = vec[i+1], loser = vec[i]"]
    F -->|No| H["winner = vec[i], loser = vec[i+1]"]
    G --> I["Push (winner, loser) to pairs"]
    H --> I
    I --> J["i += 2"]
    J --> C`,
                desc: "Forms adjacent pairs, stores the larger as 'winner' and smaller as 'loser'. Each comparison increments the global counter."
            },
            winners: {
                title: "Winner Extraction & Reordering (extractWinners + orderPairsByWinners)",
                diagram: `flowchart TD
    subgraph extractWinners
        A["From pairs, collect all winners"] --> B["Return winners array"]
    end
    subgraph orderPairsByWinners
        C["Input: pairs, sortedWinners"] --> D["For each winner in sortedWinners"]
        D --> E["Find pair with matching winner"]
        E --> F["Add pair to orderedPairs"]
        F --> G["Mark pair as used (winner = -1)"]
        G --> H["Next winner"]
        H --> D
        H --> I["Return orderedPairs"]
    end
    B -.-> C`,
                desc: "After recursive sort of winners, pairs are reordered so that their winners appear in the sorted order."
            },
            jacobsthal: {
                title: "Jacobsthal Insertion Order (generateInsertionOrder)",
                diagram: `flowchart TD
    A["Input: pendingCount n"] --> B["If n==0, return []"]
    B --> C["jacobsthal = [1, 3]"]
    C --> D["Generate Jacobsthal numbers until ‚â• n"]
    D --> E["used = array false of size n"]
    E --> F["for k = 1 to jacobsthal.length-1"]
    F --> G["start = jacobsthal[k], end = jacobsthal[k-1]"]
    G --> H["for i = start down to end+1"]
    H --> I["idx = i - 2"]
    I --> J{"idx valid and not used?"}
    J -->|Yes| K["push idx, mark used"]
    J -->|No| L["next i"]
    K --> H
    L --> H
    H --> M["next k"]
    M --> F
    M --> N["Append all unused indices in ascending order"]
    N --> O["Return insertionOrder"]`,
                desc: "Generates the optimal insertion order of pend elements using the Jacobsthal sequence (starting 1,3). Batch indices are i-2."
            },
            insert: {
                title: "Pending Insertion (insertPendingElements)",
                diagram: `flowchart TD
    A["Input: insertionOrder, orderedPairs, chain, insertionBounds, straggler"] --> B["for each step in insertionOrder"]
    B --> C{"Is this the last index and straggler exists?"}
    C -->|Yes| D["value = straggler, searchLimit = chain.length"]
    C -->|No| E["idx = step+1, value = orderedPairs[idx].loser"]
    E --> F["searchLimit = insertionBounds[idx]"]
    D --> G["pos = lower_bound(chain, value, 0, searchLimit)"]
    F --> G
    G --> H["Insert value at pos"]
    H --> I["Update insertionBounds: all bounds ‚â• pos incremented"]
    I --> J["Next step"]
    J --> B
    J --> K["Done"]`,
                desc: "Inserts each pending element (losers and straggler) into the main chain using binary search. Insertion bounds are updated after each insert."
            }
        };

        // ------------------------------------------------------------
        //  RANDOM GENERATOR (1-100, space separated)
        // ------------------------------------------------------------
        function generateRandomUniqueNumbers(count) {
            if (count > 1000) count = 1000;
            let numbers = new Set();
            while (numbers.size < count) {
                numbers.add(Math.floor(Math.random() * 100) + 1); // 1..100
            }
            return Array.from(numbers);
        }

        // ------------------------------------------------------------
        //  RUN ENGINE
        // ------------------------------------------------------------
        function runWithCustomInput(inputString) {
            let numbers = parseInput(inputString);
            if (numbers.length === 0) {
                steps = [];
                renderStep(0);
                return;
            }
            comparisonCount = 0;
            steps = [];
            let recorder = new StepRecorder();
            let frameCounter = { id: 0 };
            fordJohnsonSort(numbers, 0, recorder, frameCounter);
            steps = recorder.steps;
            currentStep = 0;
            document.getElementById('stepSlider').max = steps.length - 1;
            document.getElementById('stepLabel').innerText = `0 / ${steps.length-1}`;
            renderStep(0);
        }

        // ------------------------------------------------------------
        //  DEBOUNCE
        // ------------------------------------------------------------
        function debounce(func, wait) {
            let timeout;
            return function(...args) {
                clearTimeout(timeout);
                timeout = setTimeout(() => func.apply(this, args), wait);
            };
        }

        // ------------------------------------------------------------
        //  EVENT LISTENERS
        // ------------------------------------------------------------
        window.onload = function() {
            const inputField = document.getElementById('numberInput');
            const randomCountInput = document.getElementById('randomCount');
            const jacobsthalModal = document.getElementById('jacobsthalModal');
            const jacobsthalModalBody = document.getElementById('modalBody');
            const jacobsthalCloseBtn = document.getElementById('modalCloseBtn');
            const jacobsthalBtn = document.getElementById('jacobsthalModalBtn');
            
            const flowchartModal = document.getElementById('flowchartModal');
            const flowchartCloseBtn = document.getElementById('flowchartCloseBtn');
            const flowchartBtn = document.getElementById('flowchartBtn');
            const mermaidDiv = document.getElementById('mermaidDiagram');
            const flowchartDesc = document.getElementById('flowchartDesc');

            // Initial run
            runWithCustomInput(inputField.value);

            // Live input
            const debouncedRun = debounce(function(e) {
                runWithCustomInput(e.target.value);
            }, 400);
            inputField.addEventListener('input', debouncedRun);

            // Reset button
            document.getElementById('resetBtn').addEventListener('click', function() {
                runWithCustomInput(inputField.value);
            });

            // Random generator ‚Äì now space-separated
            document.getElementById('randomBtn').addEventListener('click', function() {
                let count = parseInt(randomCountInput.value, 10);
                if (isNaN(count) || count < 1) count = 8;
                let randoms = generateRandomUniqueNumbers(count);
                inputField.value = randoms.join(' '); // space-separated, no commas
                runWithCustomInput(inputField.value);
            });

            // Step slider & navigation
            document.getElementById('stepSlider').addEventListener('input', function(e) {
                currentStep = parseInt(e.target.value);
                renderStep(currentStep);
            });
            document.getElementById('prevBtn').addEventListener('click', function() {
                if (currentStep > 0) currentStep--;
                renderStep(currentStep);
                document.getElementById('stepSlider').value = currentStep;
            });
            document.getElementById('nextBtn').addEventListener('click', function() {
                if (currentStep < steps.length - 1) currentStep++;
                renderStep(currentStep);
                document.getElementById('stepSlider').value = currentStep;
            });
            // First and Last buttons
            document.getElementById('firstBtn').addEventListener('click', function() {
                currentStep = 0;
                renderStep(currentStep);
                document.getElementById('stepSlider').value = currentStep;
            });
            document.getElementById('lastBtn').addEventListener('click', function() {
                if (steps.length > 0) {
                    currentStep = steps.length - 1;
                    renderStep(currentStep);
                    document.getElementById('stepSlider').value = currentStep;
                }
            });

            // Arrow keys (ignore inside inputs)
            window.addEventListener('keydown', function(e) {
                const active = document.activeElement.tagName.toLowerCase();
                if (active === 'input' || active === 'textarea') return;
                if (e.key === 'ArrowLeft') { e.preventDefault(); document.getElementById('prevBtn').click(); }
                else if (e.key === 'ArrowRight') { e.preventDefault(); document.getElementById('nextBtn').click(); }
                else if (e.key === 'ArrowUp') { e.preventDefault(); document.getElementById('lastBtn').click(); }
                else if (e.key === 'ArrowDown') { e.preventDefault(); document.getElementById('firstBtn').click(); }
            });

            // ---------- JACOBSTHAL MODAL ----------
            function openJacobsthalModal() {
                // Get currently selected frame or top frame
                let selectedFrame = null;
                const selectedElem = document.querySelector('.stack-frame.selected');
                if (selectedElem) {
                    const frameId = selectedElem.getAttribute('data-frame-id');
                    if (steps[currentStep]) {
                        const frame = steps[currentStep].callStack.find(f => f.id == frameId);
                        if (frame) selectedFrame = frame;
                    }
                }
                // Fallback to top frame
                if (!selectedFrame && steps[currentStep] && steps[currentStep].callStack.length > 0) {
                    selectedFrame = steps[currentStep].callStack[steps[currentStep].callStack.length - 1];
                }

                let pendingCount = selectedFrame?.locals?.pendingCount;
                let insertionOrder = selectedFrame?.locals?.insertionOrder;
                
                if (pendingCount === undefined) {
                    jacobsthalModalBody.innerHTML = "<p>‚ö†Ô∏è No pendingCount found in current frame. Please step to a frame that has executed Jacobsthal generation.</p>";
                } else {
                    let explanation = generateJacobsthalExplanation(pendingCount, insertionOrder || []);
                    jacobsthalModalBody.innerHTML = explanation;
                }
                jacobsthalModal.style.display = 'flex';
            }

            jacobsthalBtn.addEventListener('click', openJacobsthalModal);
            jacobsthalCloseBtn.addEventListener('click', function() {
                jacobsthalModal.style.display = 'none';
            });

            // ---------- FLOWCHART MODAL ----------
            function showFlowchart(key) {
                const fc = flowcharts[key];
                mermaidDiv.innerText = fc.diagram;
                flowchartDesc.innerText = fc.desc;
                // Re-run mermaid
                mermaid.run();
            }

            flowchartBtn.addEventListener('click', function() {
                flowchartModal.style.display = 'flex';
                // Show overall by default
                showFlowchart('overall');
            });

            // Attach click handlers to option buttons
            document.querySelectorAll('[data-flowchart]').forEach(btn => {
                btn.addEventListener('click', function() {
                    const key = this.getAttribute('data-flowchart');
                    showFlowchart(key);
                });
            });

            flowchartCloseBtn.addEventListener('click', function() {
                flowchartModal.style.display = 'none';
            });

            // Close modals when clicking outside content
            window.addEventListener('click', function(e) {
                if (e.target === jacobsthalModal) {
                    jacobsthalModal.style.display = 'none';
                }
                if (e.target === flowchartModal) {
                    flowchartModal.style.display = 'none';
                }
            });
        };
    </script>
</body>
</html>
